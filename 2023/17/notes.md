A hard day! I had to peek at reddit and find people suggesting implementing Dijkstra's algorithm but instead of recording points, record a tuple of points, direction, and steps in that direction, so that's what I did.

Dijkstra's algorithm can be efficiently implemented using a priority queue. Python provides a heap and a double-ended queue but not a priority queue. Instead, I followed the Python docs [instructions on implementing a priority queue pretty much verbatim](https://docs.python.org/3/library/heapq.html#priority-queue-implementation-notes) and implement Dijkstra more or less from wikipedia, with some minor optimizations (we don't need to prepopulate the entire queue with all nodes because we'll always be adding the frontier to the queue just in time, and we can use a dictionary with a fallback of infinity to store our distances).

An interesting note: removing the counter from the PriorityQueue implementation doesn't break the logic, but it does make it slower, i think because it's actually important to maintain insertion order if we want to be fast.

The fancy logic around handling a maximum of three steps in the same diretion, or the similar logic for part 2, is handled in the function that gets the neighbors of the current node to explore next. Because we know what direction we're headed and how many steps we've gone in that direction, we just check a few hard-coded rules before adding a neighbor to the list of neighbors to check.

Some minor optimizations were made, like switching DIRECTIONS from a dictionary that we had to repeatedly call .items on to a list of tuples that we could just iterate through.