A hard day! I had to peek at reddit and find people suggesting implementing Dijkstra's algorithm but instead of recording points, record a tuple of points, direction, and steps in that direction, so that's what I did.

Dijkstra's algorithm can be efficiently implemented using a priority queue. Python provides a heap and a double-ended queue but not a priority queue. Instead, I followed the Python docs [instructions on implementing a priority queue pretty much verbatim](https://docs.python.org/3/library/heapq.html#priority-queue-implementation-notes) and implement Dijkstra more or less from wikipedia, with some minor optimizations (we don't need to prepopulate the entire queue with all nodes because we'll always be adding the frontier to the queue just in time, and we can use a defaultdict that returns infinity for absent keys to record our distances).

The fancy logic around handling a maximum of three steps in the same diretion, or the similar logic for part 2, is handled in the function that gets the neighbors of the current node to explore next. Because we know what direction we're headed and how many steps we've gone in that direction, we just check a few hard-coded rules before adding a neighbor to the list of neighbors to check.