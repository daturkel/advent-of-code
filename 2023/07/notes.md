Another nice and easy day. We take advantage of the fact that Python has built in support for lexical sorting of tuples/lists (and even nested data structures), so all we have to do to sort the hands is prepend the hand value to them (and map each card to the correct value). We have an alternate mapping to take care of the low value of Js and maintain representations of the hands with both high and low jack values.

To interpret each hand type, we transform a hand into a count of card types, then look at the counts: [5] is 5 of a kind, [1,4] is four of a kind, and so on. When interpreting hand types, we manually check if there's a J and if so how many of it, and we can re-interpret the hand. In [1,2,2], a single J means full house and 2 Js means four of a kind. 0 Js means the original hand value.