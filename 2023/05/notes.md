This was a really hard one! We're tracking mappings of integers through a series of rules for transforming them.

In part a, the only insight is to only bother to keep track of mappings that possibly apply to any of the starting seeds and their descendants.

In part b, there are now way too many seeds to keep track of, so we need to start mapping intervals to intervals. That's actually not very hard. The tricky part is remembering the rule that any unmapped numbers from the previous round will just get mapped to themselves. I prayed that you would never have an interval that was only *partially* mapped in the last round (i.e. if the last round had an interval (1,12), then either (1,12) would be entirely mapped this round, or else be entirely mapped to itself). Unfortunately, this assumption was wrong (in the real input, though not in the test), we DO need to consiering the possibility of intervals that were only *partially* mapped through rules this round. That means we need to map only the subsets of an interval that weren't mapped. So if (1,12) is an interval, and we did map (3,5) and (7,9), then we need to map (1,2), (6,6), and (10,12) to themselves, but leave the (3,5) and (7,9) mappings intact. I used a single function to calculate overlaps (which we need elsewhere) and set differences (a minus b) and use that to figure out just the subset of each interval that needs to be self-mapped. The code is ugly but it all runs in under a second.